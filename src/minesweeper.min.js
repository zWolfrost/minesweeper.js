export default class a{constructor(c,d,a=Math.floor(c*d/5),p=Math.random){function l(b,a){let c=[a=validateNumber(a,0,b.cells-1)],f=a%b.width,g=Math.floor(a/b.width),d=g>0,e=g<b.height-1;return d&&c.push(a-b.width),e&&c.push(a+b.width),f>0&&(c.push(a-1),d&&c.push(a-b.width-1),e&&c.push(a+b.width-1)),f<b.width-1&&(c.push(a+1),d&&c.push(a-b.width+1),e&&c.push(a+b.width+1)),c}c=validateNumber(c,0),d=validateNumber(d,0);let b=c*d;if(Array.isArray(a)){Object.assign(this,{width:c,height:d,cells:b,mines:a.length});for(let i=0;i<b;i++)this[i]={mines:0,isMine:!1,isOpen:!1,isFlagged:!1};for(let f=0;f<a.length;f++){this[a[f]].isMine=!0;let m=l(this,a[f]);for(let j=0;j<m.length;j++)this[m[j]].mines++}}else{a=validateNumber(a,0,b),Object.assign(this,{width:c,height:d,cells:b,mines:a});for(let g=0;g<b;g++)this[g]={mines:0,isMine:g<a,isOpen:!1,isFlagged:!1};for(let e=b-1;e>0;e--){let n=Math.floor(p()*(e+1));[this[e],this[n]]=[this[n],this[e]]}for(let h=0;h<b;h++)if(this[h].isMine){let o=l(this,h);for(let k=0;k<o.length;k++)this[o[k]].mines++}}return this}toMinefield2D(){let c=new Minefield2D(this.width,this.height);for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)delete c[a][b],c[a][b]=this[a+b*this.width];return c}openCell(a,i=this.isNew()){a=validateNumber(a,0,this.cells-1);let e=[],f=c=>{let b=this.getEmptyZone(c);for(let a=0;a<b.length;a++)this[b[a]].isOpen=!0,e.push(b[a])};if(!1==this[a].isOpen){if(this[a].isOpen=!0,e.push(a),this[a].isMine){if(i){this[a].isMine=!1;for(let d=0;d<this.cells;d++)if(!1==this[d].isMine&&d!=a){this[d].isMine=!0;break}this.resetMines(),f(a)}}else f(a)}else if(0!=this[a].mines){let b=this.getNearbyCells(a),h=0;for(let g=0;g<b.length;g++)this[b[g]].isFlagged&&h++;if(h==this[a].mines)for(let c=0;c<b.length;c++)!1==this[b[c]].isFlagged&& !1==this[b[c]].isOpen&&(this[b[c]].isOpen=!0,e.push(b[c]),!1==this[b[c]].isMine&&f(b[c]))}return e}isSolvableFrom(z,I=!0){z=validateNumber(z,0,this.cells-1);let A=(a,b)=>JSON.stringify(a).includes(JSON.stringify(b)),B=this.openCell(z);if(B.length<=1&&0!=this[B[0]].mines)return I&&(this[B[0]].isOpen=!1),!1;let b=!0;for(;b;){let a=[];b=!1;let i=[];for(let j=0;j<this.cells;j++)if(!1==this[j].isOpen&& !1==this[j].isFlagged){let C=this.getNearbyCells(j);for(let r=0;r<C.length;r++)!0==this[C[r]].isOpen&&i.push(C[r])}for(let d of i=[...new Set(i)])if(0==this[d].mines){let D=this.getEmptyZone(d);for(let s=0;s<D.length;s++)!1==this[D[s]].isOpen&&(this[D[s]].isOpen=!0,b=!0)}else{let t=this.getNearbyCells(d),J=0,u=0,k=[];for(let l=0;l<t.length;l++)!1==this[t[l]].isOpen&&(J++,this[t[l]].isFlagged?u++:k.push(t[l]));if(k.length>0&&(this[d].mines==u&&(k.forEach(a=>this[a].isOpen=!0),b=!0),this[d].mines==J&&(k.forEach(a=>this[a].isFlagged=!0),b=!0),this[d].mines>u)){let K=[this[d].mines-u,...k.sort((a,b)=>a-b)];!1==A(a,K)&&a.push(K)}}if(!1==b){let v=!0;for(;v;)for(let L of(v=!1,i)){let w=this.getNearbyCells(L),m=[0],E=[],M=0;for(let n=0;n<w.length;n++)this[w[n]].isFlagged?M++:!1==this[w[n]].isOpen&&E.push(w[n]);for(let c=0;c<a.length;c++)if(a[c].slice(1).every(a=>E.includes(a))&&E.length!=a[c].length-1){let N=E.filter(b=>!1==a[c].includes(b,1)).sort((a,b)=>a-b),O=this[L].mines-a[c][0]-M,P=[O,...N];if(N.length>0&&O>0&& !1==A(a,P)){let Q=!0;for(let F=0;F<a.length;F++)if(a[F].every(a=>P.includes(a))){Q=!1;break}Q&&(a.push(P),v=!0)}!1==a[c].slice(1).some(a=>m.includes(a,1))&&(m[0]+=a[c][0],m.push(...a[c].slice(1)))}m[0]>0&& !1==A(a,m)&&(a.push(m),v=!0)}for(let G of i){let e=this.getNearbyCells(G);for(let f=0;f<a.length;f++)if(e.some(b=>a[f].includes(b,1))){let S=a[f].slice(1).filter(a=>!1==e.includes(a)).length,H=0,o=[];for(let g=0;g<e.length;g++)this[e[g]].isFlagged?H++:!1==this[e[g]].isOpen&& !1==a[f].includes(e[g],1)&&o.push(e[g]);o.length>0&&(this[G].mines==H+a[f][0]+o.length&&(o.forEach(a=>this[a].isFlagged=!0),b=!0),this[G].mines==H+a[f][0]-S&& !1==b&&o.forEach(a=>{!1==this[a].isFlagged&&(this[a].isOpen=!0,b=!0)}))}}}if(!1==b){if(this.usedFlags==this.mines)for(let p=0;p<this.cells;p++)!1==this[p].isOpen&& !1==this[p].isFlagged&&(this[p].isOpen=!0);else{a.sort((a,b)=>a.length-b.length);let x=[0];for(let q=0;q<a.length;q++)!1==a[q].slice(1).some(a=>JSON.stringify(x.slice(1)).includes(a))&&(x[0]+=a[q][0],x.push(...a[q].slice(1)));if(x[0]==this.mines-this.usedFlags)for(let h=0;h<this.cells;h++)!1==this[h].isOpen&& !1==this[h].isFlagged&& !1==x.includes(h,1)&&(this[h].isOpen=!0,b=!0)}}}let R=!1;if(this.isCleared()&&(R=!0),I)for(let y=0;y<this.cells;y++)this[y].isOpen=!1,this[y].isFlagged=!1;return R}getHint(R=!1,S=!0){let z=(a,b)=>JSON.stringify(a).includes(JSON.stringify(b)),c=[],d=[],a=[],l=[];for(let m=0;m<this.cells;m++)if(!1==this[m].isOpen&& !1==this[m].isFlagged){let A=this.getNearbyCells(m);for(let u=0;u<A.length;u++)!0==this[A[u]].isOpen&&l.push(A[u])}for(let b of l=[...new Set(l)])if(this[b].isOpen){if(0==this[b].mines){let H=this.getNearbyCells(b),I=H.filter(a=>!1==this[a].isOpen);I.length>0&&(c.push(["O",...H,b]),d.push(["O",...I]))}else{let j=this.getNearbyCells(b),J=0,v=0,n=[];for(let o=0;o<j.length;o++)!1==this[j[o]].isOpen&&(J++,this[j[o]].isFlagged?v++:n.push(j[o]));if(n.length>0&&(this[b].mines==v&&(c.push(["O",...j,b]),d.push(["O",...n])),this[b].mines==J&&(c.push(["F",...j,b]),d.push(["F",...n])),this[b].mines>v)){let K=[this[b].mines-v,...n.sort((a,b)=>a-b)];!1==z(a,K)&&a.push(K)}}}let w=!0;for(;w;)for(let L of(w=!1,l)){let x=this.getNearbyCells(L),p=[0],B=[],M=0;for(let q=0;q<x.length;q++)this[x[q]].isFlagged?M++:!1==this[x[q]].isOpen&&B.push(x[q]);for(let f=0;f<a.length;f++)if(a[f].slice(1).every(a=>B.includes(a))&&B.length!=a[f].length-1){let N=B.filter(b=>!1==a[f].includes(b,1)).sort((a,b)=>a-b),O=this[L].mines-a[f][0]-M,P=[O,...N];if(N.length>0&&O>0&& !1==z(a,P)){let Q=!0;for(let C=0;C<a.length;C++)if(a[C].every(a=>P.includes(a))){Q=!1;break}Q&&(a.push(P),w=!0)}!1==a[f].slice(1).some(a=>p.includes(a,1))&&(p[0]+=a[f][0],p.push(...a[f].slice(1)))}p[0]>0&& !1==z(a,p)&&(a.push(p),w=!0)}for(let r of l){let e=this.getNearbyCells(r);for(let h=0;h<a.length;h++)if(e.some(b=>a[h].includes(b,1))){let T=a[h].slice(1).filter(a=>!1==e.includes(a)).length,D=0,i=[],E=[];for(let g=0;g<e.length;g++){let U=this.getNearbyCells(e[g]);a[h].slice(1).every(a=>U.includes(a))&&this[e[g]].isOpen&&E.push(...U),this[e[g]].isFlagged?D++:!1==this[e[g]].isOpen&& !1==a[h].includes(e[g],1)&&i.push(e[g])}i.length>0&&(this[r].mines==D+a[h][0]+i.length?(c.push(["F",...new Set([...e,...E,r])]),d.push(["F",...i])):this[r].mines==D+a[h][0]-T&&(i=i.filter(a=>!1==this[a].isFlagged)).length>0&&(c.push(["O",...new Set([...e,...E,r])]),d.push(["O",...i])))}}if(this.usedFlags==this.mines){let F=[];for(let s=0;s<this.cells;s++)!1==this[s].isOpen&& !1==this[s].isFlagged&&F.push(s);c.push(["O",...F]),d.push(["O",...F])}else{a.sort((a,b)=>a.length-b.length);let y=[0];for(let t=0;t<a.length;t++)!1==a[t].slice(1).some(a=>JSON.stringify(y.slice(1)).includes(a))&&(y[0]+=a[t][0],y.push(...a[t].slice(1)));if(y[0]==this.mines-this.usedFlags){let G=[];for(let k=0;k<this.cells;k++)!1==this[k].isOpen&& !1==this[k].isFlagged&& !1==y.includes(k,1)&&G.push(k);c.push(["O",...G]),d.push(["O",...G])}}return S&&(c=c[0],d=d[0]),(R?d:c)??[]}resetMines(){for(let b=0;b<this.cells;b++)this[b].mines=0;for(let a=0;a<this.cells;a++)if(this[a].isMine){let d=this.getNearbyCells(a,!0);for(let c=0;c<d.length;c++)this[d[c]].mines++}}getCellArray(){return Object.values(this).slice(0,this.cells)}getNearbyCells(a,g=!1){a=validateNumber(a,0,this.cells-1);let b=[],e=a%this.width,f=Math.floor(a/this.width),c=f>0,d=f<this.height-1;return g&&b.push(a),c&&b.push(a-this.width),d&&b.push(a+this.width),e>0&&(b.push(a-1),c&&b.push(a-this.width-1),d&&b.push(a+this.width-1)),e<this.width-1&&(b.push(a+1),c&&b.push(a-this.width+1),d&&b.push(a+this.width+1)),b}getEmptyZone(m,n=!1){let c=this.width;if(0!=this[m].mines)return[];let b=new Set,e=[m];for(;e.length;){let a=e.pop();for(;a>=0&&0==this[a].mines;)a-=c;a+=c;let f=!1,g=!1;for(;a<this.cells&&0==this[a].mines;)b.add(a),a%c>0&&(0==this[a-1].mines&& !1==b.has(a-1)?!1==f&&(e.push(a-1),f=!0):f&&(f=!1)),a%c<c-1&&(0==this[a+1].mines&& !1==b.has(a+1)?!1==g&&(e.push(a+1),g=!0):g&&(g=!1)),a+=c}let j=new Set;if(n)for(let o of b){let k=this.getNearbyCells(o);for(let h=0;h<k.length;h++)0!=this[k[h]].mines&&j.add(k[h])}else for(let l of b){this[l].isFlagged&&b.delete(l);let i=this.getNearbyCells(l);for(let d=0;d<i.length;d++)0!=this[i[d]].mines&& !1==this[i[d]].isFlagged&&j.add(i[d])}return[...b,...j]}getCellCords(a){return[(a=validateNumber(a))%this.width,Math.floor(a/this.width)]}getCellIndex(a,b){return(a=validateNumber(a))+(b=validateNumber(b))*this.width}isNew(){for(let a=0;a<this.cells;a++)if(this[a].isOpen)return!1;return!0}isGoingOn(){let b=!1,c=!1;for(let a=0;a<this.cells;a++){if(this[a].isOpen&&this[a].isMine)return!1;this[a].isOpen&&(c=!0),!1==this[a].isOpen&& !1==this[a].isMine&&(b=!0)}return c&&b}isOver(){let b=!1;for(let a=0;a<this.cells;a++)if(!1==this[a].isOpen&& !1==this[a].isMine&&(b=!0),this[a].isOpen&&this[a].isMine)return!0;return!1==b}isCleared(){for(let a=0;a<this.cells;a++)if(!1==this[a].isOpen&& !1==this[a].isMine||this[a].isOpen&&this[a].isMine)return!1;return!0}isLost(){for(let a=0;a<this.cells;a++)if(this[a].isOpen&&this[a].isMine)return!0;return!1}visualDebug(d=!1){let c="";for(let a=0;a<this.cells;a++){let b="";!1==this[a].isOpen&& !1==d?this[a].isFlagged?b+="F":b+="?":!0==this[a].isMine?b+="X":b+=this[a].mines,(a+1)%this.width==0?c+=b+"\n":c+=b+" "}console.log(c)}get usedFlags(){let b=0;for(let a=0;a<this.cells;a++)this[a].isFlagged&&b++;return b}};class Minefield2D extends a{constructor(a,d,g=Math.floor(a*d/5),h=Math.random){super(a,d,g,h);let e=[];for(let b=0;b<a;b++){e.push([]);for(let c=0;c<d;c++)e[b][c]=this[b+c*a]}for(let f=0;f<this.cells;f++)delete this[f];return Object.assign(this,e),this}toMinefield(){let d=new a(this.width,this.height);for(let b=0;b<this.width;b++)for(let c=0;c<this.height;c++)delete d[b+c*this.width],d[b+c*this.width]=this[b][c];return d}openCell(a,b,g=this.isNew()){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1);let c=this.toMinefield(),h=c.getCellIndex(a,b),e=c.openCell(h,g),f=[];for(let d=0;d<e.length;d++)f.push(c.getCellCords(e[d]));return f}isSolvableFrom(a,b,d=!0){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1);let c=this.toMinefield(),e=c.getCellIndex(a,b);return c.isSolvableFrom(e,d)}getHint(g=!1,d=!0){let e=this.toMinefield(),a=e.getHint(g,d);if(0==a.length)return[];d&&(a=[a]);let c=[];for(let b=0;b<a.length;b++){c.push([a[0][0]]);for(let f=1;f<a[b].length;f++)c[b].push(e.getCellCords(a[b]))}return c}resetMines(){for(let d=0;d<this.width;d++)for(let e=0;e<this.height;e++)this[d][e].mines=0;for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(this[a][b].isMine){let f=this.getNearbyCells(a,b,!0);for(let c=0;c<f.length;c++)this[f[c][0]][f[c][1]].mines++}}getCellArray(){let c=[];for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)c.push(this[a][b]);return c}getNearbyCells(a,b,f=!1){a=validateNumber(a,0,this.width-1);let c=[],d=(b=validateNumber(b,0,this.height-1))>0,e=b<this.height-1;return f&&c.push([a,b]),d&&c.push([a,b-1]),e&&c.push([a,b+1]),a>0&&(c.push([a-1,b]),d&&c.push([a-1,b-1]),e&&c.push([a-1,b+1])),a<this.width-1&&(c.push([a+1,b]),d&&c.push([a+1,b-1]),e&&c.push([a+1,b+1])),c}getEmptyZone(e,f,g=!1){let a=this.toMinefield(),h=a.getCellIndex(e,f),c=a.getEmptyZone(h,g),d=[];for(let b=0;b<c.length;b++)d.push(a.getCellCords(c[b]));return d}isNew(){for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(this[a][b].isOpen)return!1;return!0}isGoingOn(){let c=!1,d=!1;for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++){if(this[a][b].isOpen&&this[a][b].isMine)return!1;this[a][b].isOpen&&(d=!0),!1==this[a][b].isOpen&& !1==this[a][b].isMine&&(c=!0)}return d&&c}isOver(){let c=!1;for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(!1==this[a][b].isOpen&& !1==this[a][b].isMine&&(c=!0),this[a][b].isOpen&&this[a][b].isMine)return!0;return!1==c}isCleared(){for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(!1==this[a][b].isOpen&& !1==this[a][b].isMine||this[a][b].isOpen&&this[a][b].isMine)return!1;return!0}isLost(){for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(this[a][b].isOpen&&this[a][b].isMine)return!0;return!1}visualDebug(a=!1){this.toMinefield().visualDebug(a)}get usedFlags(){let c=0;for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)this[a][b].isFlagged&&c++;return c}}function validateNumber(a,b=-1/0,c=1/0){try{if(a=Math.trunc(b>=0?Math.abs(+a):+a),isNaN(a))throw new Error}catch{throw new Error("Invalid parameter type")}if(a<b)throw new Error("Parameter value is too small");if(a>c)throw new Error("Parameter value is too big");return a}