export default class a{constructor(c,d,a=Math.floor(c*d/5),p=Math.random){let l=a=>{let b=[a],e=a%this.width,f=Math.floor(a/this.width),c=f>0,d=f<this.height-1;return c&&b.push(a-this.width),d&&b.push(a+this.width),e>0&&(b.push(a-1),c&&b.push(a-this.width-1),d&&b.push(a+this.width-1)),e<this.width-1&&(b.push(a+1),c&&b.push(a-this.width+1),d&&b.push(a+this.width+1)),b};c=validateNumber(c,0),d=validateNumber(d,0);let b=c*d;if(Array.isArray(a)){Object.assign(this,{width:c,height:d,cells:b,mines:a.length});for(let i=0;i<b;i++)this[i]={mines:0,isMine:!1,isOpen:!1,isFlagged:!1};for(let f=0;f<a.length;f++){this[a[f]].isMine=!0;let m=l(a[f]);for(let j=0;j<m.length;j++)this[m[j]].mines++}}else{a=validateNumber(a,0,b),Object.assign(this,{width:c,height:d,cells:b,mines:a});for(let g=0;g<b;g++)this[g]={mines:0,isMine:g<a,isOpen:!1,isFlagged:!1};for(let e=b-1;e>0;e--){let n=Math.floor(p()*(e+1));[this[e],this[n]]=[this[n],this[e]]}for(let h=0;h<b;h++)if(this[h].isMine){let o=l(h);for(let k=0;k<o.length;k++)this[o[k]].mines++}}return this}toMinefield2D(){if(this instanceof Minefield2D)throw new Error("This object is already an instance of Minefield2D");let c=new Minefield2D(this.width,this.height);for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)delete c[a][b],c[a][b]=this[a+b*this.width];return c}simplify(){let b=[];for(let a=0;a<this.cells;a++)b.push(this[a].isMine?-1:this[a].mines);return b}openCell(a,n=this.isNew(),{nearbyOpening:j=!0,nearbyFlagging:k=!0}={}){a=validateNumber(a,0,this.cells-1);let c=[],i=d=>{let b=this.getEmptyZone(d);for(let a=0;a<b.length;a++)this[b[a]].isOpen=!0,c.push(b[a])};if(!1==this[a].isOpen){if(this[a].isOpen=!0,c.push(a),this[a].isMine){if(n){this[a].isMine=!1;for(let e=0;e<this.cells;e++)if(!1==this[e].isMine&&e!=a){this[e].isMine=!0;break}this.resetMines(),i(a)}}else i(a)}else if(0!=this[a].mines&&(j||k)){let g=this.getNearbyCells(a),l=0,m=0,b=[];for(let f=0;f<g.length;f++)!1==this[g[f]].isOpen&&(l++,this[g[f]].isFlagged?m++:b.push(g[f]));if(this[a].mines==m&&j)for(let d=0;d<b.length;d++)this[b[d]].isOpen=!0,c.push(b[d]),!1==this[b[d]].isMine&&i(b[d]);else if(this[a].mines==l&&k)for(let h=0;h<b.length;h++)this[b[h]].isFlagged=!0,c.push(b[h])}return c.length>=2&&c[0]==c[1]&&c.shift(),c}isSolvableFrom(z,I=!0){z=validateNumber(z,0,this.cells-1);let A=(a,b)=>JSON.stringify(a).includes(JSON.stringify(b)),B=this.openCell(z);if(B.length<=1&&0!=this[B[0]].mines)return I&&(this[B[0]].isOpen=!1),!1;let b=!0;for(;b;){let a=[];b=!1;let i=new Set;for(let j=0;j<this.cells;j++)if(!1==this[j].isOpen&& !1==this[j].isFlagged){let C=this.getNearbyCells(j);for(let r=0;r<C.length;r++)!0==this[C[r]].isOpen&&i.add(C[r])}for(let d of i=[...i])if(0==this[d].mines){let D=this.getEmptyZone(d);for(let s=0;s<D.length;s++)!1==this[D[s]].isOpen&&(this[D[s]].isOpen=!0,b=!0)}else{let t=this.getNearbyCells(d),J=0,u=0,k=[];for(let l=0;l<t.length;l++)!1==this[t[l]].isOpen&&(J++,this[t[l]].isFlagged?u++:k.push(t[l]));if(k.length>0){if(this[d].mines==u){for(let T of k)this[T].isOpen=!0;b=!0}if(this[d].mines==J){for(let U of k)this[U].isFlagged=!0;b=!0}if(this[d].mines>u){let K=[this[d].mines-u,...k.sort((a,b)=>a-b)];!1==A(a,K)&&a.push(K)}}}if(!1==b){let v=!0;for(;v;)for(let L of(v=!1,i)){let w=this.getNearbyCells(L),m=[0],E=[],M=0;for(let n=0;n<w.length;n++)this[w[n]].isFlagged?M++:!1==this[w[n]].isOpen&&E.push(w[n]);for(let c=0;c<a.length;c++)if(a[c].slice(1).every(a=>E.includes(a))&&E.length!=a[c].length-1){let N=E.filter(b=>!1==a[c].includes(b,1)).sort((a,b)=>a-b),O=this[L].mines-a[c][0]-M,P=[O,...N];if(N.length>0&&O>0&& !1==A(a,P)){let Q=!0;for(let F=0;F<a.length;F++)if(a[F].every(a=>P.includes(a))){Q=!1;break}Q&&(a.push(P),v=!0)}!1==a[c].slice(1).some(a=>m.includes(a,1))&&(m[0]+=a[c][0],m.push(...a[c].slice(1)))}m[0]>0&& !1==A(a,m)&&(a.push(m),v=!0)}for(let G of i){let e=this.getNearbyCells(G);for(let f=0;f<a.length;f++)if(e.some(b=>a[f].includes(b,1))){let V=a[f].slice(1).filter(a=>!1==e.includes(a)).length,H=0,o=[];for(let g=0;g<e.length;g++)this[e[g]].isFlagged?H++:!1==this[e[g]].isOpen&& !1==a[f].includes(e[g],1)&&o.push(e[g]);if(o.length>0){if(this[G].mines==H+a[f][0]+o.length){for(let W of o)this[W].isFlagged=!0;b=!0}if(this[G].mines==H+a[f][0]-V&& !1==b)for(let R of o)!1==this[R].isFlagged&&(this[R].isOpen=!0,b=!0)}}}if(!1==b){if(this.usedFlags==this.mines)for(let p=0;p<this.cells;p++)!1==this[p].isOpen&& !1==this[p].isFlagged&&(this[p].isOpen=!0);else{a.sort((a,b)=>a.length-b.length);let x=[0];for(let q=0;q<a.length;q++)!1==a[q].slice(1).some(a=>JSON.stringify(x.slice(1)).includes(a))&&(x[0]+=a[q][0],x.push(...a[q].slice(1)));if(x[0]==this.mines-this.usedFlags)for(let h=0;h<this.cells;h++)!1==this[h].isOpen&& !1==this[h].isFlagged&& !1==x.includes(h,1)&&(this[h].isOpen=!0,b=!0)}}}}let S=!1;if(this.isCleared()&&(S=!0),I)for(let y=0;y<this.cells;y++)this[y].isOpen=!1,this[y].isFlagged=!1;return S}getHint(R=!1,S=!0){let B=(a,b)=>JSON.stringify(a).includes(JSON.stringify(b)),c=[],d=[],a=[],l=new Set;for(let m=0;m<this.cells;m++)if(!1==this[m].isOpen&& !1==this[m].isFlagged){let C=this.getNearbyCells(m);for(let u=0;u<C.length;u++)!0==this[C[u]].isOpen&&l.add(C[u])}for(let b of l=[...l])if(this[b].isOpen){if(0==this[b].mines){let H=this.getNearbyCells(b),I=H.filter(a=>!1==this[a].isOpen);I.length>0&&(c.push(["O",...H,b]),d.push(["O",...I]))}else{let j=this.getNearbyCells(b),J=0,v=0,n=[];for(let o=0;o<j.length;o++)!1==this[j[o]].isOpen&&(J++,this[j[o]].isFlagged?v++:n.push(j[o]));if(n.length>0&&(this[b].mines==v&&(c.push(["O",...j,b]),d.push(["O",...n])),this[b].mines==J&&(c.push(["F",...j,b]),d.push(["F",...n])),this[b].mines>v)){let K=[this[b].mines-v,...n.sort((a,b)=>a-b)];!1==B(a,K)&&a.push(K)}}}let w=!0;for(;w;)for(let L of(w=!1,l)){let x=this.getNearbyCells(L),p=[0],D=[],M=0;for(let q=0;q<x.length;q++)this[x[q]].isFlagged?M++:!1==this[x[q]].isOpen&&D.push(x[q]);for(let f=0;f<a.length;f++)if(a[f].slice(1).every(a=>D.includes(a))&&D.length!=a[f].length-1){let N=D.filter(b=>!1==a[f].includes(b,1)).sort((a,b)=>a-b),O=this[L].mines-a[f][0]-M,P=[O,...N];if(N.length>0&&O>0&& !1==B(a,P)){let Q=!0;for(let E=0;E<a.length;E++)if(a[E].every(a=>P.includes(a))){Q=!1;break}Q&&(a.push(P),w=!0)}!1==a[f].slice(1).some(a=>p.includes(a,1))&&(p[0]+=a[f][0],p.push(...a[f].slice(1)))}p[0]>0&& !1==B(a,p)&&(a.push(p),w=!0)}for(let r of l){let e=this.getNearbyCells(r);for(let h=0;h<a.length;h++)if(e.some(b=>a[h].includes(b,1))){let T=a[h].slice(1).filter(a=>!1==e.includes(a)).length,F=0,i=[],G=[];for(let g=0;g<e.length;g++){let U=this.getNearbyCells(e[g]);a[h].slice(1).every(a=>U.includes(a))&&this[e[g]].isOpen&&G.push(...U),this[e[g]].isFlagged?F++:!1==this[e[g]].isOpen&& !1==a[h].includes(e[g],1)&&i.push(e[g])}i.length>0&&(this[r].mines==F+a[h][0]+i.length?(c.push(["F",...new Set([...e,...G,r])]),d.push(["F",...i])):this[r].mines==F+a[h][0]-T&&(i=i.filter(a=>!1==this[a].isFlagged)).length>0&&(c.push(["O",...new Set([...e,...G,r])]),d.push(["O",...i])))}}if(this.usedFlags==this.mines){let y=[];for(let s=0;s<this.cells;s++)!1==this[s].isOpen&& !1==this[s].isFlagged&&y.push(s);y.length>0&&(c.push(["O",...y]),d.push(["O",...y]))}else{a.sort((a,b)=>a.length-b.length);let z=[0];for(let t=0;t<a.length;t++)!1==a[t].slice(1).some(a=>JSON.stringify(z.slice(1)).includes(a))&&(z[0]+=a[t][0],z.push(...a[t].slice(1)));if(z[0]==this.mines-this.usedFlags){let A=[];for(let k=0;k<this.cells;k++)!1==this[k].isOpen&& !1==this[k].isFlagged&& !1==z.includes(k,1)&&A.push(k);A.length>0&&(c.push(["O",...A]),d.push(["O",...A]))}}return S&&(c=c[0],d=d[0]),(R?d:c)??[]}resetMines(){for(let b=0;b<this.cells;b++)this[b].mines=0;for(let a=0;a<this.cells;a++)if(this[a].isMine){let d=this.getNearbyCells(a,!0);for(let c=0;c<d.length;c++)this[d[c]].mines++}}forEachCell(c,d=!1,e=!0){for(let a=0;a<this.cells;a++){let b=c(this[a],e?a:[a%this.width,Math.floor(a/this.width)]);if(d&& void 0!==b)return b}}getNearbyCells(a,g=!1){a=validateNumber(a,0,this.cells-1);let b=[],e=a%this.width,f=Math.floor(a/this.width),c=f>0,d=f<this.height-1;return g&&b.push(a),c&&b.push(a-this.width),d&&b.push(a+this.width),e>0&&(b.push(a-1),c&&b.push(a-this.width-1),d&&b.push(a+this.width-1)),e<this.width-1&&(b.push(a+1),c&&b.push(a-this.width+1),d&&b.push(a+this.width+1)),b}getEmptyZone(d,f=!1){if(0!=this[d].mines)return[];let b=new Set([d]);for(let e of b)if(0==this[e].mines){let c=this.getNearbyCells(e);for(let a=0;a<c.length;a++)(f|| !1==this[c[a]].isFlagged)&&b.add(c[a])}return[...b]}getSquareZone(c,d){c=validateNumber(c,0,this.cells-1),d=validateNumber(d,0,this.cells-1);let a=[c%this.width,Math.floor(c/this.width)],b=[d%this.width,Math.floor(d/this.width)];b[0]<a[0]&&([a[0],b[0]]=[b[0],a[0]]),b[1]<a[1]&&([a[1],b[1]]=[b[1],a[1]]);let g=[];for(let e=a[0];e<=b[0];e++)for(let f=a[1];f<=b[1];f++)g.push(e+f*this.width);return g}getCellCords(a){return[(a=validateNumber(a))%this.width,Math.floor(a/this.width)]}getCellIndex([a,b]){return(a=validateNumber(a))+(b=validateNumber(b))*this.width}isNew(){return this.forEachCell(a=>{if(a.isOpen)return!1},!0)?? !0}isGoingOn(){let a=!1,b=!1;return this.forEachCell(c=>{if(c.isOpen&&c.isMine)return!1;c.isOpen?b=!0:!1==c.isOpen&& !1==c.isMine&&(a=!0)},!0)??(b&&a)}isOver(){let a=!1;return this.forEachCell(b=>{if(!1==b.isOpen&& !1==b.isMine)a=!0;else if(b.isOpen&&b.isMine)return!0},!0)?? !1==a}isCleared(){return this.forEachCell(a=>{if(!1==a.isOpen&& !1==a.isMine||a.isOpen&&a.isMine)return!1},!0)?? !0}isLost(){return this.forEachCell(a=>{if(a.isOpen&&a.isMine)return!0},!0)?? !1}visualDebug(b=!1){let a="";this.forEachCell((d,e)=>{let c="";!1==d.isOpen&& !1==b?d.isFlagged?c+="F":c+="?":!0==d.isMine?c+="X":c+=d.mines,(e+1)%this.width==0?a+=c+"\n":a+=c+" "},!1,!0),console.log(a)}get usedFlags(){let a=0;return this.forEachCell(b=>{b.isFlagged&&a++}),a}};class Minefield2D extends a{constructor(a,d,g=Math.floor(a*d/5),h=Math.random){super(a,d,g,h);let e=[];for(let b=0;b<a;b++){e.push([]);for(let c=0;c<d;c++)e[b][c]=this[b+c*a]}for(let f=0;f<this.cells;f++)delete this[f];return Object.assign(this,e),this}toMinefield(){let d=new a(this.width,this.height);for(let b=0;b<this.width;b++)for(let c=0;c<this.height;c++)delete d[b+c*this.width],d[b+c*this.width]=this[b][c];return d}simplify(){let b=[];for(let a=0;a<this.width;a++){b.push([]);for(let c=0;c<this.height;c++){let d=this[a][c];b[a].push(d.isMine?-1:d.mines)}}return b}openCell([a,b],g=this.isNew(),{nearbyOpening:h=!0,nearbyFlagging:i=!0}={}){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1);let c=this.toMinefield(),j=c.getCellIndex([a,b]),e=c.openCell(j,g,{nearbyOpening:h,nearbyFlagging:i}),f=[];for(let d=0;d<e.length;d++)f.push(c.getCellCords(e[d]));return f}isSolvableFrom([a,b],d=!0){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1);let c=this.toMinefield(),e=c.getCellIndex([a,b]);return c.isSolvableFrom(e,d)}getHint(g=!1,e=!0){let f=this.toMinefield(),a=f.getHint(g,e);if(0==a.length)return[];e&&(a=[a]);let c=[];for(let b=0;b<a.length;b++){c.push([a[0][0]]);for(let d=1;d<a[b].length;d++)c[b].push(f.getCellCords(a[b][d]))}return c}resetMines(){for(let d=0;d<this.width;d++)for(let e=0;e<this.height;e++)this[d][e].mines=0;for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(this[a][b].isMine){let f=this.getNearbyCells([a,b],!0);for(let c=0;c<f.length;c++)this[f[c][0]][f[c][1]].mines++}}forEachCell(d,e=!1,f=!1){for(let a=0;a<this.height;a++)for(let b=0;b<this.width;b++){let c=d(this[b][a],f?b+a*this.width:[b,a]);if(e&& void 0!==c)return c}}getNearbyCells([a,b],f=!1){a=validateNumber(a,0,this.width-1);let c=[],d=(b=validateNumber(b,0,this.height-1))>0,e=b<this.height-1;return f&&c.push([a,b]),d&&c.push([a,b-1]),e&&c.push([a,b+1]),a>0&&(c.push([a-1,b]),d&&c.push([a-1,b-1]),e&&c.push([a-1,b+1])),a<this.width-1&&(c.push([a+1,b]),d&&c.push([a+1,b-1]),e&&c.push([a+1,b+1])),c}getEmptyZone([e,f],g=!1){let a=this.toMinefield(),h=a.getCellIndex([e,f]),c=a.getEmptyZone(h,g),d=[];for(let b=0;b<c.length;b++)d.push(a.getCellCords(c[b]));return d}getSquareZone([a,b],[c,d]){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1),c=validateNumber(c,0,this.width-1),d=validateNumber(d,0,this.height-1),c<a&&([a,c]=[c,a]),d<b&&([b,d]=[d,b]);let g=[];for(let e=a;e<=c;e++)for(let f=b;f<=d;f++)g.push([e,f]);return g}}function validateNumber(a,b=-1/0,c=1/0){try{if(a=Math.trunc(b>=0?Math.abs(+a):+a),isNaN(a))throw 0}catch{throw new Error("Invalid parameter type")}if(a<b)throw new Error("Parameter value is too small");if(a>c)throw new Error("Parameter value is too big");return a}