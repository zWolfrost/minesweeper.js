export default class a{constructor(c,d,a=Math.floor(c*d/5),p=Math.random){let l=a=>{let b=[a],e=a%this.width,f=Math.floor(a/this.width),c=f>0,d=f<this.height-1;return c&&b.push(a-this.width),d&&b.push(a+this.width),e>0&&(b.push(a-1),c&&b.push(a-this.width-1),d&&b.push(a+this.width-1)),e<this.width-1&&(b.push(a+1),c&&b.push(a-this.width+1),d&&b.push(a+this.width+1)),b};c=validateNumber(c,0),d=validateNumber(d,0);let b=c*d;if(Array.isArray(a)){Object.assign(this,{width:c,height:d,cells:b,mines:a.length});for(let i=0;i<b;i++)this[i]={mines:0,isMine:!1,isOpen:!1,isFlagged:!1};for(let f=0;f<a.length;f++){this[a[f]].isMine=!0;let m=l(a[f]);for(let j=0;j<m.length;j++)this[m[j]].mines++}}else{a=validateNumber(a,0,b),Object.assign(this,{width:c,height:d,cells:b,mines:a});for(let g=0;g<b;g++)this[g]={mines:0,isMine:g<a,isOpen:!1,isFlagged:!1};for(let e=b-1;e>0;e--){let n=Math.floor(p()*(e+1));[this[e],this[n]]=[this[n],this[e]]}for(let h=0;h<b;h++)if(this[h].isMine){let o=l(h);for(let k=0;k<o.length;k++)this[o[k]].mines++}}return this}toMinefield2D(){let c=new Minefield2D(this.width,this.height);for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)delete c[a][b],c[a][b]=this[a+b*this.width];return c}simplify(){let b=[];for(let a=0;a<this.cells;a++)b.push(this[a].isMine?-1:this[a].mines);return b}openCell(a,n=this.isNew(),{nearbyOpening:j=!0,nearbyFlagging:k=!0}={}){a=validateNumber(a,0,this.cells-1);let c=[],i=d=>{let b=this.getEmptyZone(d);for(let a=0;a<b.length;a++)this[b[a]].isOpen=!0,c.push(b[a])};if(!1==this[a].isOpen){if(this[a].isOpen=!0,c.push(a),this[a].isMine){if(n){this[a].isMine=!1;for(let e=0;e<this.cells;e++)if(!1==this[e].isMine&&e!=a){this[e].isMine=!0;break}this.resetMines(),i(a)}}else i(a)}else if(0!=this[a].mines&&(j||k)){let g=this.getNearbyCells(a),l=0,m=0,b=[];for(let f=0;f<g.length;f++)!1==this[g[f]].isOpen&&(l++,this[g[f]].isFlagged?m++:b.push(g[f]));if(this[a].mines==m&&j)for(let d=0;d<b.length;d++)this[b[d]].isOpen=!0,c.push(b[d]),!1==this[b[d]].isMine&&i(b[d]);else if(this[a].mines==l&&k)for(let h=0;h<b.length;h++)this[b[h]].isFlagged=!0,c.push(b[h])}return c.length>=2&&c[0]==c[1]&&c.shift(),c}isSolvableFrom(z,I=!0){z=validateNumber(z,0,this.cells-1);let A=(a,b)=>JSON.stringify(a).includes(JSON.stringify(b)),B=this.openCell(z);if(B.length<=1&&0!=this[B[0]].mines)return I&&(this[B[0]].isOpen=!1),!1;let b=!0;for(;b;){let a=[];b=!1;let i=[];for(let j=0;j<this.cells;j++)if(!1==this[j].isOpen&& !1==this[j].isFlagged){let C=this.getNearbyCells(j);for(let r=0;r<C.length;r++)!0==this[C[r]].isOpen&&i.push(C[r])}for(let d of i=[...new Set(i)])if(0==this[d].mines){let D=this.getEmptyZone(d);for(let s=0;s<D.length;s++)!1==this[D[s]].isOpen&&(this[D[s]].isOpen=!0,b=!0)}else{let t=this.getNearbyCells(d),J=0,u=0,k=[];for(let l=0;l<t.length;l++)!1==this[t[l]].isOpen&&(J++,this[t[l]].isFlagged?u++:k.push(t[l]));if(k.length>0&&(this[d].mines==u&&(k.forEach(a=>this[a].isOpen=!0),b=!0),this[d].mines==J&&(k.forEach(a=>this[a].isFlagged=!0),b=!0),this[d].mines>u)){let K=[this[d].mines-u,...k.sort((a,b)=>a-b)];!1==A(a,K)&&a.push(K)}}if(!1==b){let v=!0;for(;v;)for(let L of(v=!1,i)){let w=this.getNearbyCells(L),m=[0],E=[],M=0;for(let n=0;n<w.length;n++)this[w[n]].isFlagged?M++:!1==this[w[n]].isOpen&&E.push(w[n]);for(let c=0;c<a.length;c++)if(a[c].slice(1).every(a=>E.includes(a))&&E.length!=a[c].length-1){let N=E.filter(b=>!1==a[c].includes(b,1)).sort((a,b)=>a-b),O=this[L].mines-a[c][0]-M,P=[O,...N];if(N.length>0&&O>0&& !1==A(a,P)){let Q=!0;for(let F=0;F<a.length;F++)if(a[F].every(a=>P.includes(a))){Q=!1;break}Q&&(a.push(P),v=!0)}!1==a[c].slice(1).some(a=>m.includes(a,1))&&(m[0]+=a[c][0],m.push(...a[c].slice(1)))}m[0]>0&& !1==A(a,m)&&(a.push(m),v=!0)}for(let G of i){let e=this.getNearbyCells(G);for(let f=0;f<a.length;f++)if(e.some(b=>a[f].includes(b,1))){let S=a[f].slice(1).filter(a=>!1==e.includes(a)).length,H=0,o=[];for(let g=0;g<e.length;g++)this[e[g]].isFlagged?H++:!1==this[e[g]].isOpen&& !1==a[f].includes(e[g],1)&&o.push(e[g]);o.length>0&&(this[G].mines==H+a[f][0]+o.length&&(o.forEach(a=>this[a].isFlagged=!0),b=!0),this[G].mines==H+a[f][0]-S&& !1==b&&o.forEach(a=>{!1==this[a].isFlagged&&(this[a].isOpen=!0,b=!0)}))}}}if(!1==b){if(this.usedFlags==this.mines)for(let p=0;p<this.cells;p++)!1==this[p].isOpen&& !1==this[p].isFlagged&&(this[p].isOpen=!0);else{a.sort((a,b)=>a.length-b.length);let x=[0];for(let q=0;q<a.length;q++)!1==a[q].slice(1).some(a=>JSON.stringify(x.slice(1)).includes(a))&&(x[0]+=a[q][0],x.push(...a[q].slice(1)));if(x[0]==this.mines-this.usedFlags)for(let h=0;h<this.cells;h++)!1==this[h].isOpen&& !1==this[h].isFlagged&& !1==x.includes(h,1)&&(this[h].isOpen=!0,b=!0)}}}let R=!1;if(this.isCleared()&&(R=!0),I)for(let y=0;y<this.cells;y++)this[y].isOpen=!1,this[y].isFlagged=!1;return R}getHint(R=!1,S=!0){let z=(a,b)=>JSON.stringify(a).includes(JSON.stringify(b)),c=[],d=[],a=[],l=[];for(let m=0;m<this.cells;m++)if(!1==this[m].isOpen&& !1==this[m].isFlagged){let A=this.getNearbyCells(m);for(let u=0;u<A.length;u++)!0==this[A[u]].isOpen&&l.push(A[u])}for(let b of l=[...new Set(l)])if(this[b].isOpen){if(0==this[b].mines){let H=this.getNearbyCells(b),I=H.filter(a=>!1==this[a].isOpen);I.length>0&&(c.push(["O",...H,b]),d.push(["O",...I]))}else{let j=this.getNearbyCells(b),J=0,v=0,n=[];for(let o=0;o<j.length;o++)!1==this[j[o]].isOpen&&(J++,this[j[o]].isFlagged?v++:n.push(j[o]));if(n.length>0&&(this[b].mines==v&&(c.push(["O",...j,b]),d.push(["O",...n])),this[b].mines==J&&(c.push(["F",...j,b]),d.push(["F",...n])),this[b].mines>v)){let K=[this[b].mines-v,...n.sort((a,b)=>a-b)];!1==z(a,K)&&a.push(K)}}}let w=!0;for(;w;)for(let L of(w=!1,l)){let x=this.getNearbyCells(L),p=[0],B=[],M=0;for(let q=0;q<x.length;q++)this[x[q]].isFlagged?M++:!1==this[x[q]].isOpen&&B.push(x[q]);for(let f=0;f<a.length;f++)if(a[f].slice(1).every(a=>B.includes(a))&&B.length!=a[f].length-1){let N=B.filter(b=>!1==a[f].includes(b,1)).sort((a,b)=>a-b),O=this[L].mines-a[f][0]-M,P=[O,...N];if(N.length>0&&O>0&& !1==z(a,P)){let Q=!0;for(let C=0;C<a.length;C++)if(a[C].every(a=>P.includes(a))){Q=!1;break}Q&&(a.push(P),w=!0)}!1==a[f].slice(1).some(a=>p.includes(a,1))&&(p[0]+=a[f][0],p.push(...a[f].slice(1)))}p[0]>0&& !1==z(a,p)&&(a.push(p),w=!0)}for(let r of l){let e=this.getNearbyCells(r);for(let h=0;h<a.length;h++)if(e.some(b=>a[h].includes(b,1))){let T=a[h].slice(1).filter(a=>!1==e.includes(a)).length,D=0,i=[],E=[];for(let g=0;g<e.length;g++){let U=this.getNearbyCells(e[g]);a[h].slice(1).every(a=>U.includes(a))&&this[e[g]].isOpen&&E.push(...U),this[e[g]].isFlagged?D++:!1==this[e[g]].isOpen&& !1==a[h].includes(e[g],1)&&i.push(e[g])}i.length>0&&(this[r].mines==D+a[h][0]+i.length?(c.push(["F",...new Set([...e,...E,r])]),d.push(["F",...i])):this[r].mines==D+a[h][0]-T&&(i=i.filter(a=>!1==this[a].isFlagged)).length>0&&(c.push(["O",...new Set([...e,...E,r])]),d.push(["O",...i])))}}if(this.usedFlags==this.mines){let F=[];for(let s=0;s<this.cells;s++)!1==this[s].isOpen&& !1==this[s].isFlagged&&F.push(s);c.push(["O",...F]),d.push(["O",...F])}else{a.sort((a,b)=>a.length-b.length);let y=[0];for(let t=0;t<a.length;t++)!1==a[t].slice(1).some(a=>JSON.stringify(y.slice(1)).includes(a))&&(y[0]+=a[t][0],y.push(...a[t].slice(1)));if(y[0]==this.mines-this.usedFlags){let G=[];for(let k=0;k<this.cells;k++)!1==this[k].isOpen&& !1==this[k].isFlagged&& !1==y.includes(k,1)&&G.push(k);c.push(["O",...G]),d.push(["O",...G])}}return S&&(c=c[0],d=d[0]),(R?d:c)??[]}resetMines(){for(let b=0;b<this.cells;b++)this[b].mines=0;for(let a=0;a<this.cells;a++)if(this[a].isMine){let d=this.getNearbyCells(a,!0);for(let c=0;c<d.length;c++)this[d[c]].mines++}}forEachCell(c,i=!1,f=!0){if(i){if(f)for(let d=0;d<this.cells;d++){let g=c(this[d],d);if(void 0!==g)return g}else for(let a=0;a<this.cells;a++){let h=c(this[a],[a%this.width,Math.floor(a/this.width)]);if(void 0!==h)return h}}else if(f)for(let e=0;e<this.cells;e++)c(this[e],e);else for(let b=0;b<this.cells;b++)c(this[b],[b%this.width,Math.floor(b/this.width)])}getNearbyCells(a,g=!1){a=validateNumber(a,0,this.cells-1);let b=[],e=a%this.width,f=Math.floor(a/this.width),c=f>0,d=f<this.height-1;return g&&b.push(a),c&&b.push(a-this.width),d&&b.push(a+this.width),e>0&&(b.push(a-1),c&&b.push(a-this.width-1),d&&b.push(a+this.width-1)),e<this.width-1&&(b.push(a+1),c&&b.push(a-this.width+1),d&&b.push(a+this.width+1)),b}getEmptyZone(e,i=!1){if(0!=this[e].mines)return[];let a=new Set([e]);if(i){for(let f of a)if(0==this[f].mines){let g=this.getNearbyCells(f);for(let c=0;c<g.length;c++)a.add(g[c])}}else for(let h of a)if(0==this[h].mines){let d=this.getNearbyCells(h);for(let b=0;b<d.length;b++)!1==this[d[b]].isFlagged&&a.add(d[b])}return[...a]}getSquareZone(a,b){a=validateNumber(a,0,this.cells-1),(b=validateNumber(b,0,this.cells-1))<a&&([a,b]=[b,a]);let f=this.getCellCords(a)[0],g=this.getCellCords(b)[0],d=[];for(let c=a;c<=b;c++){let e=this.getCellCords(c)[0];f<=e&&e<=g&&d.push(c)}return d}getCellCords(a){return[(a=validateNumber(a))%this.width,Math.floor(a/this.width)]}getCellIndex([a,b]){return(a=validateNumber(a))+(b=validateNumber(b))*this.width}isNew(){return this.forEachCell(a=>{if(a.isOpen)return!1},!0)?? !0}isGoingOn(){let a=!1,b=!1;return this.forEachCell(c=>{if(c.isOpen&&c.isMine)return!1;c.isOpen?b=!0:!1==c.isOpen&& !1==c.isMine&&(a=!0)},!0)??(b&&a)}isOver(){let a=!1;return this.forEachCell(b=>{if(!1==b.isOpen&& !1==b.isMine)a=!0;else if(b.isOpen&&b.isMine)return!0},!0)?? !1==a}isCleared(){return this.forEachCell(a=>{if(!1==a.isOpen&& !1==a.isMine||a.isOpen&&a.isMine)return!1},!0)?? !0}isLost(){return this.forEachCell(a=>{if(a.isOpen&&a.isMine)return!0},!0)?? !1}visualDebug(b=!1){let a="";this.forEachCell((d,e)=>{let c="";!1==d.isOpen&& !1==b?d.isFlagged?c+="F":c+="?":!0==d.isMine?c+="X":c+=d.mines,(e+1)%this.width==0?a+=c+"\n":a+=c+" "},!1,!0),console.log(a)}get usedFlags(){let a=0;return this.forEachCell(b=>{b.isFlagged&&a++}),a}};class Minefield2D extends a{constructor(a,d,g=Math.floor(a*d/5),h=Math.random){super(a,d,g,h);let e=[];for(let b=0;b<a;b++){e.push([]);for(let c=0;c<d;c++)e[b][c]=this[b+c*a]}for(let f=0;f<this.cells;f++)delete this[f];return Object.assign(this,e),this}toMinefield(){let d=new a(this.width,this.height);for(let b=0;b<this.width;b++)for(let c=0;c<this.height;c++)delete d[b+c*this.width],d[b+c*this.width]=this[b][c];return d}simplify(){let b=[];for(let a=0;a<this.width;a++){b.push([]);for(let c=0;c<this.height;c++){let d=this[a][c];b[a].push(d.isMine?-1:d.mines)}}return b}openCell([a,b],g=this.isNew(),{nearbyOpening:h=!0,nearbyFlagging:i=!0}={}){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1);let c=this.toMinefield(),j=c.getCellIndex([a,b]),e=c.openCell(j,g,{nearbyOpening:h,nearbyFlagging:i}),f=[];for(let d=0;d<e.length;d++)f.push(c.getCellCords(e[d]));return f}isSolvableFrom([a,b],d=!0){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1);let c=this.toMinefield(),e=c.getCellIndex([a,b]);return c.isSolvableFrom(e,d)}getHint(g=!1,e=!0){let f=this.toMinefield(),a=f.getHint(g,e);if(0==a.length)return[];e&&(a=[a]);let c=[];for(let b=0;b<a.length;b++){c.push([a[0][0]]);for(let d=1;d<a[b].length;d++)c[b].push(f.getCellCords(a[b][d]))}return c}resetMines(){for(let d=0;d<this.width;d++)for(let e=0;e<this.height;e++)this[d][e].mines=0;for(let a=0;a<this.width;a++)for(let b=0;b<this.height;b++)if(this[a][b].isMine){let f=this.getNearbyCells([a,b],!0);for(let c=0;c<f.length;c++)this[f[c][0]][f[c][1]].mines++}}forEachCell(a,m=!1,j=!1){if(m){if(j)for(let b=0;b<this.height;b++)for(let c=0;c<this.width;c++){let k=a(this[c][b],c+b*this.width);if(void 0!==k)return k}else for(let d=0;d<this.height;d++)for(let e=0;e<this.width;e++){let l=a(this[e][d],[e,d]);if(void 0!==l)return l}}else if(j)for(let f=0;f<this.height;f++)for(let g=0;g<this.width;g++)a(this[g][f],g+f*this.width);else for(let h=0;h<this.height;h++)for(let i=0;i<this.width;i++)a(this[i][h],[i,h])}getNearbyCells([a,b],f=!1){a=validateNumber(a,0,this.width-1);let c=[],d=(b=validateNumber(b,0,this.height-1))>0,e=b<this.height-1;return f&&c.push([a,b]),d&&c.push([a,b-1]),e&&c.push([a,b+1]),a>0&&(c.push([a-1,b]),d&&c.push([a-1,b-1]),e&&c.push([a-1,b+1])),a<this.width-1&&(c.push([a+1,b]),d&&c.push([a+1,b-1]),e&&c.push([a+1,b+1])),c}getEmptyZone([e,f],g=!1){let a=this.toMinefield(),h=a.getCellIndex([e,f]),c=a.getEmptyZone(h,g),d=[];for(let b=0;b<c.length;b++)d.push(a.getCellCords(c[b]));return d}getSquareZone([a,b],[c,d]){a=validateNumber(a,0,this.width-1),b=validateNumber(b,0,this.height-1),c=validateNumber(c,0,this.width-1),d=validateNumber(d,0,this.height-1),c<a&&([a,c]=[c,a]),d<b&&([b,d]=[d,b]);let g=[];for(let e=a;e<=c;e++)for(let f=b;f<=d;f++)g.push([e,f]);return g}}function validateNumber(a,b=-1/0,c=1/0){try{if(a=Math.trunc(b>=0?Math.abs(+a):+a),isNaN(a))throw new Error}catch{throw new Error("Invalid parameter type")}if(a<b)throw new Error("Parameter value is too small");if(a>c)throw new Error("Parameter value is too big");return a}