export default class e{constructor(e,t,i=Math.floor(e*t/5),s=Math.random){let h=e=>{let t=[e],i=e%this.width,s=Math.floor(e/this.width),h=s>0,l=s<this.height-1;return h&&t.push(e-this.width),l&&t.push(e+this.width),i>0&&(t.push(e-1),h&&t.push(e-this.width-1),l&&t.push(e+this.width-1)),i<this.width-1&&(t.push(e+1),h&&t.push(e-this.width+1),l&&t.push(e+this.width+1)),t},l=(e=validateNumber(e,0))*(t=validateNumber(t,0));if(Array.isArray(i)){Object.assign(this,{width:e,height:t,cells:l,mines:i.length});for(let n=0;n<l;n++)this[n]={mines:0,isMine:!1,isOpen:!1,isFlagged:!1};for(let r=0;r<i.length;r++){this[i[r]].isMine=!0;let $=h(i[r]);for(let f=0;f<$.length;f++)this[$[f]].mines++}}else{i=validateNumber(i,0,l),Object.assign(this,{width:e,height:t,cells:l,mines:i});for(let o=0;o<l;o++)this[o]={mines:0,isMine:o<i,isOpen:!1,isFlagged:!1};for(let _=l-1;_>0;_--){let g=Math.floor(s()*(_+1));[this[_],this[g]]=[this[g],this[_]]}for(let u=0;u<l;u++)if(this[u].isMine){let d=h(u);for(let a=0;a<d.length;a++)this[d[a]].mines++}}return this}toMinefield2D(){if(this instanceof Minefield2D)throw Error("This object is already an instance of Minefield2D");let e=new Minefield2D(this.width,this.height);for(let t=0;t<this.width;t++)for(let i=0;i<this.height;i++)delete e[t][i],e[t][i]=this[t+i*this.width];return e}simplify(){let e=[];for(let t=0;t<this.cells;t++)e.push(this[t].isMine?-1:this[t].mines);return e}openCell(e,t=this.isNew(),{nearbyOpening:i=!0,nearbyFlagging:s=!0}={}){e=validateNumber(e,0,this.cells-1);let h=[],l=e=>{let t=this.getEmptyZone(e);for(let i=0;i<t.length;i++)this[t[i]].isOpen=!0,h.push(t[i])};if(!1==this[e].isOpen){if(this[e].isOpen=!0,h.push(e),this[e].isMine){if(t){this[e].isMine=!1;for(let n=0;n<this.cells;n++)if(!1==this[n].isMine&&n!=e){this[n].isMine=!0;break}this.resetMines(),l(e)}}else l(e)}else if(0!=this[e].mines&&(i||s)){let r=this.getNearbyCells(e),$=0,f=0,o=[];for(let _=0;_<r.length;_++)!1==this[r[_]].isOpen&&($++,this[r[_]].isFlagged?f++:o.push(r[_]));if(this[e].mines==f&&i)for(let g=0;g<o.length;g++)this[o[g]].isOpen=!0,h.push(o[g]),!1==this[o[g]].isMine&&l(o[g]);else if(this[e].mines==$&&s)for(let u=0;u<o.length;u++)this[o[u]].isFlagged=!0,h.push(o[u])}return h.length>=2&&h[0]==h[1]&&h.shift(),h}isSolvableFrom(e,t=!0){e=validateNumber(e,0,this.cells-1);let i=(e,t)=>JSON.stringify(e).includes(JSON.stringify(t)),s=this.openCell(e);if(s.length<=1&&0!=this[s[0]].mines)return t&&(this[s[0]].isOpen=!1),!1;let h=!0;for(;h;){let l=[];h=!1;let n=new Set;for(let r=0;r<this.cells;r++)if(!1==this[r].isOpen&&!1==this[r].isFlagged){let $=this.getNearbyCells(r);for(let f=0;f<$.length;f++)!0==this[$[f]].isOpen&&n.add($[f])}for(let o of n=[...n])if(0==this[o].mines){let _=this.getEmptyZone(o);for(let g=0;g<_.length;g++)!1==this[_[g]].isOpen&&(this[_[g]].isOpen=!0,h=!0)}else{let u=this.getNearbyCells(o),d=0,a=0,p=[];for(let m=0;m<u.length;m++)!1==this[u[m]].isOpen&&(d++,this[u[m]].isFlagged?a++:p.push(u[m]));if(p.length>0){if(this[o].mines==a){for(let c of p)this[c].isOpen=!0;h=!0}if(this[o].mines==d){for(let w of p)this[w].isFlagged=!0;h=!0}if(this[o].mines>a){let O=[this[o].mines-a,...p.sort((e,t)=>e-t)];!1==i(l,O)&&l.push(O)}}}if(!1==h){let b=!0;for(;b;)for(let C of(b=!1,n)){let N=this.getNearbyCells(C),y=[0],F=[],v=0;for(let M=0;M<N.length;M++)this[N[M]].isFlagged?v++:!1==this[N[M]].isOpen&&F.push(N[M]);for(let E=0;E<l.length;E++)if(l[E].slice(1).every(e=>F.includes(e))&&F.length!=l[E].length-1){let Z=F.filter(e=>!1==l[E].includes(e,1)).sort((e,t)=>e-t),x=this[C].mines-l[E][0]-v,D=[x,...Z];if(Z.length>0&&x>0&&!1==i(l,D)){let I=!0;for(let S=0;S<l.length;S++)if(l[S].every(e=>D.includes(e))){I=!1;break}I&&(l.push(D),b=!0)}!1==l[E].slice(1).some(e=>y.includes(e,1))&&(y[0]+=l[E][0],y.push(...l[E].slice(1)))}y[0]>0&&!1==i(l,y)&&(l.push(y),b=!0)}for(let k of n){let H=this.getNearbyCells(k);for(let q=0;q<l.length;q++)if(H.some(e=>l[q].includes(e,1))){let P=l[q].slice(1).filter(e=>!1==H.includes(e)).length,j=0,A=[];for(let G=0;G<H.length;G++)this[H[G]].isFlagged?j++:!1==this[H[G]].isOpen&&!1==l[q].includes(H[G],1)&&A.push(H[G]);if(A.length>0){if(this[k].mines==j+l[q][0]+A.length){for(let L of A)this[L].isFlagged=!0;h=!0}if(this[k].mines==j+l[q][0]-P&&!1==h)for(let T of A)!1==this[T].isFlagged&&(this[T].isOpen=!0,h=!0)}}}if(!1==h){if(this.usedFlags==this.mines)for(let X=0;X<this.cells;X++)!1==this[X].isOpen&&!1==this[X].isFlagged&&(this[X].isOpen=!0);else{l.sort((e,t)=>e.length-t.length);let z=[0];for(let B=0;B<l.length;B++)!1==l[B].slice(1).some(e=>JSON.stringify(z.slice(1)).includes(e))&&(z[0]+=l[B][0],z.push(...l[B].slice(1)));if(z[0]==this.mines-this.usedFlags)for(let J=0;J<this.cells;J++)!1==this[J].isOpen&&!1==this[J].isFlagged&&!1==z.includes(J,1)&&(this[J].isOpen=!0,h=!0)}}}}let K=!1;if(this.isCleared()&&(K=!0),t)for(let Q=0;Q<this.cells;Q++)this[Q].isOpen=!1,this[Q].isFlagged=!1;return K}getHint(e=!1,t=!0){let i=(e,t)=>JSON.stringify(e).includes(JSON.stringify(t)),s=[],h=[],l=[],n=new Set;for(let r=0;r<this.cells;r++)if(!1==this[r].isOpen&&!1==this[r].isFlagged){let $=this.getNearbyCells(r);for(let f=0;f<$.length;f++)!0==this[$[f]].isOpen&&n.add($[f])}for(let o of n=[...n])if(this[o].isOpen){if(0==this[o].mines){let _=this.getNearbyCells(o),g=_.filter(e=>!1==this[e].isOpen);g.length>0&&(s.push(["O",..._,o]),h.push(["O",...g]))}else{let u=this.getNearbyCells(o),d=0,a=0,p=[];for(let m=0;m<u.length;m++)!1==this[u[m]].isOpen&&(d++,this[u[m]].isFlagged?a++:p.push(u[m]));if(p.length>0&&(this[o].mines==a&&(s.push(["O",...u,o]),h.push(["O",...p])),this[o].mines==d&&(s.push(["F",...u,o]),h.push(["F",...p])),this[o].mines>a)){let c=[this[o].mines-a,...p.sort((e,t)=>e-t)];!1==i(l,c)&&l.push(c)}}}let w=!0;for(;w;)for(let O of(w=!1,n)){let b=this.getNearbyCells(O),C=[0],N=[],y=0;for(let F=0;F<b.length;F++)this[b[F]].isFlagged?y++:!1==this[b[F]].isOpen&&N.push(b[F]);for(let v=0;v<l.length;v++)if(l[v].slice(1).every(e=>N.includes(e))&&N.length!=l[v].length-1){let M=N.filter(e=>!1==l[v].includes(e,1)).sort((e,t)=>e-t),E=this[O].mines-l[v][0]-y,Z=[E,...M];if(M.length>0&&E>0&&!1==i(l,Z)){let x=!0;for(let D=0;D<l.length;D++)if(l[D].every(e=>Z.includes(e))){x=!1;break}x&&(l.push(Z),w=!0)}!1==l[v].slice(1).some(e=>C.includes(e,1))&&(C[0]+=l[v][0],C.push(...l[v].slice(1)))}C[0]>0&&!1==i(l,C)&&(l.push(C),w=!0)}for(let I of n){let S=this.getNearbyCells(I);for(let k=0;k<l.length;k++)if(S.some(e=>l[k].includes(e,1))){let H=l[k].slice(1).filter(e=>!1==S.includes(e)).length,q=0,P=[],j=[];for(let A=0;A<S.length;A++){let G=this.getNearbyCells(S[A]);l[k].slice(1).every(e=>G.includes(e))&&this[S[A]].isOpen&&j.push(...G),this[S[A]].isFlagged?q++:!1==this[S[A]].isOpen&&!1==l[k].includes(S[A],1)&&P.push(S[A])}P.length>0&&(this[I].mines==q+l[k][0]+P.length?(s.push(["F",...new Set([...S,...j,I])]),h.push(["F",...P])):this[I].mines==q+l[k][0]-H&&(P=P.filter(e=>!1==this[e].isFlagged)).length>0&&(s.push(["O",...new Set([...S,...j,I])]),h.push(["O",...P])))}}if(this.usedFlags==this.mines){let L=[];for(let T=0;T<this.cells;T++)!1==this[T].isOpen&&!1==this[T].isFlagged&&L.push(T);L.length>0&&(s.push(["O",...L]),h.push(["O",...L]))}else{l.sort((e,t)=>e.length-t.length);let X=[0];for(let z=0;z<l.length;z++)!1==l[z].slice(1).some(e=>JSON.stringify(X.slice(1)).includes(e))&&(X[0]+=l[z][0],X.push(...l[z].slice(1)));if(X[0]==this.mines-this.usedFlags){let B=[];for(let J=0;J<this.cells;J++)!1==this[J].isOpen&&!1==this[J].isFlagged&&!1==X.includes(J,1)&&B.push(J);B.length>0&&(s.push(["O",...B]),h.push(["O",...B]))}}return t&&(s=s[0],h=h[0]),(e?h:s)??[]}resetMines(){for(let e=0;e<this.cells;e++)this[e].mines=0;for(let t=0;t<this.cells;t++)if(this[t].isMine){let i=this.getNearbyCells(t,!0);for(let s=0;s<i.length;s++)this[i[s]].mines++}}forEachCell(e,t=!1,i=!0){for(let s=0;s<this.cells;s++){let h=e(this[s],i?s:[s%this.width,Math.floor(s/this.width)]);if(t&&void 0!==h)return h}}getNearbyCells(e,t=!1){e=validateNumber(e,0,this.cells-1);let i=[],s=e%this.width,h=Math.floor(e/this.width),l=h>0,n=h<this.height-1;return t&&i.push(e),l&&i.push(e-this.width),n&&i.push(e+this.width),s>0&&(i.push(e-1),l&&i.push(e-this.width-1),n&&i.push(e+this.width-1)),s<this.width-1&&(i.push(e+1),l&&i.push(e-this.width+1),n&&i.push(e+this.width+1)),i}getEmptyZone(e,t=!1){if(0!=this[e].mines)return[];let i=new Set([e]);for(let s of i)if(0==this[s].mines){let h=this.getNearbyCells(s);for(let l=0;l<h.length;l++)(t||!1==this[h[l]].isFlagged)&&i.add(h[l])}return[...i]}getSquareZone(e,t){e=validateNumber(e,0,this.cells-1),t=validateNumber(t,0,this.cells-1);let i=[e%this.width,Math.floor(e/this.width)],s=[t%this.width,Math.floor(t/this.width)];s[0]<i[0]&&([i[0],s[0]]=[s[0],i[0]]),s[1]<i[1]&&([i[1],s[1]]=[s[1],i[1]]);let h=[];for(let l=i[0];l<=s[0];l++)for(let n=i[1];n<=s[1];n++)h.push(l+n*this.width);return h}getCellCords(e){return[(e=validateNumber(e))%this.width,Math.floor(e/this.width)]}getCellIndex([e,t]){return(e=validateNumber(e))+(t=validateNumber(t))*this.width}isNew(){return this.forEachCell(e=>{if(e.isOpen)return!1},!0)??!0}isGoingOn(){let e=!1,t=!1;return this.forEachCell(i=>{if(i.isOpen&&i.isMine)return!1;i.isOpen?t=!0:!1==i.isOpen&&!1==i.isMine&&(e=!0)},!0)??(t&&e)}isOver(){let e=!1;return this.forEachCell(t=>{if(!1==t.isOpen&&!1==t.isMine)e=!0;else if(t.isOpen&&t.isMine)return!0},!0)??!1==e}isCleared(){return this.forEachCell(e=>{if(!1==e.isOpen&&!1==e.isMine||e.isOpen&&e.isMine)return!1},!0)??!0}isLost(){return this.forEachCell(e=>{if(e.isOpen&&e.isMine)return!0},!0)??!1}visualDebug(e=!1){let t="";this.forEachCell((i,s)=>{let h="";!1==i.isOpen&&!1==e?i.isFlagged?h+="F":h+="?":!0==i.isMine?h+="X":h+=i.mines,(s+1)%this.width==0?t+=h+"\n":t+=h+" "},!1,!0),console.log(t)}get usedFlags(){let e=0;return this.forEachCell(t=>{t.isFlagged&&e++}),e}};class Minefield2D extends e{constructor(e,t,i=Math.floor(e*t/5),s=Math.random){super(e,t,i,s);let h=[];for(let l=0;l<e;l++){h.push([]);for(let n=0;n<t;n++)h[l][n]=this[l+n*e]}for(let r=0;r<this.cells;r++)delete this[r];return Object.assign(this,h),this}toMinefield(){let t=new e(this.width,this.height);for(let i=0;i<this.width;i++)for(let s=0;s<this.height;s++)delete t[i+s*this.width],t[i+s*this.width]=this[i][s];return t}simplify(){let e=[];for(let t=0;t<this.width;t++){e.push([]);for(let i=0;i<this.height;i++){let s=this[t][i];e[t].push(s.isMine?-1:s.mines)}}return e}openCell([e,t],i=this.isNew(),{nearbyOpening:s=!0,nearbyFlagging:h=!0}={}){e=validateNumber(e,0,this.width-1),t=validateNumber(t,0,this.height-1);let l=this.toMinefield(),n=l.getCellIndex([e,t]),r=l.openCell(n,i,{nearbyOpening:s,nearbyFlagging:h}),$=[];for(let f=0;f<r.length;f++)$.push(l.getCellCords(r[f]));return $}isSolvableFrom([e,t],i=!0){e=validateNumber(e,0,this.width-1),t=validateNumber(t,0,this.height-1);let s=this.toMinefield(),h=s.getCellIndex([e,t]);return s.isSolvableFrom(h,i)}getHint(e=!1,t=!0){let i=this.toMinefield(),s=i.getHint(e,t);if(0==s.length)return[];t&&(s=[s]);let h=[];for(let l=0;l<s.length;l++){h.push([s[0][0]]);for(let n=1;n<s[l].length;n++)h[l].push(i.getCellCords(s[l][n]))}return h}resetMines(){for(let e=0;e<this.width;e++)for(let t=0;t<this.height;t++)this[e][t].mines=0;for(let i=0;i<this.width;i++)for(let s=0;s<this.height;s++)if(this[i][s].isMine){let h=this.getNearbyCells([i,s],!0);for(let l=0;l<h.length;l++)this[h[l][0]][h[l][1]].mines++}}forEachCell(e,t=!1,i=!1){for(let s=0;s<this.height;s++)for(let h=0;h<this.width;h++){let l=e(this[h][s],i?h+s*this.width:[h,s]);if(t&&void 0!==l)return l}}getNearbyCells([e,t],i=!1){e=validateNumber(e,0,this.width-1);let s=[],h=(t=validateNumber(t,0,this.height-1))>0,l=t<this.height-1;return i&&s.push([e,t]),h&&s.push([e,t-1]),l&&s.push([e,t+1]),e>0&&(s.push([e-1,t]),h&&s.push([e-1,t-1]),l&&s.push([e-1,t+1])),e<this.width-1&&(s.push([e+1,t]),h&&s.push([e+1,t-1]),l&&s.push([e+1,t+1])),s}getEmptyZone([e,t],i=!1){let s=this.toMinefield(),h=s.getCellIndex([e,t]),l=s.getEmptyZone(h,i),n=[];for(let r=0;r<l.length;r++)n.push(s.getCellCords(l[r]));return n}getSquareZone([e,t],[i,s]){e=validateNumber(e,0,this.width-1),t=validateNumber(t,0,this.height-1),i=validateNumber(i,0,this.width-1),s=validateNumber(s,0,this.height-1),i<e&&([e,i]=[i,e]),s<t&&([t,s]=[s,t]);let h=[];for(let l=e;l<=i;l++)for(let n=t;n<=s;n++)h.push([l,n]);return h}}function validateNumber(e,t=-1/0,i=1/0){try{if(e=Math.trunc(t>=0?Math.abs(+e):+e),isNaN(e))throw 0}catch{throw Error("Invalid parameter type")}if(e<t)throw Error("Parameter value is too small");if(e>i)throw Error("Parameter value is too big");return e}